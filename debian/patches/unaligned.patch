From fb86387b18e7db4be5eebbc11a76e9542bc1f620 Mon Sep 17 00:00:00 2001
From: Mark Wielaard <mjw@redhat.com>
Date: Sun, 15 Jun 2014 22:14:04 +0200
Subject: [PATCH] libdwfl: linux-core-attach.c handle possible unaligned data
 access.

Use libdw/memory-access.h macros read_4ubyte_unaligned_noncvt and
read_8ubyte_unaligned_noncvt to access possibly unaligned data in
core files.

Signed-off-by: Mark Wielaard <mjw@redhat.com>

Index: elfutils-0.159/libdwfl/linux-core-attach.c
===================================================================
--- elfutils-0.159.orig/libdwfl/linux-core-attach.c
+++ elfutils-0.159/libdwfl/linux-core-attach.c
@@ -59,6 +59,8 @@
 # endif
 #endif
 
+#include "../libdw/memory-access.h"
+
 #ifndef MIN
 # define MIN(a, b) ((a) < (b) ? (a) : (b))
 #endif
@@ -112,12 +114,10 @@ core_memory_read (Dwfl *dwfl, Dwarf_Addr
 	  return false;
 	}
       assert (data->d_size == bytes);
-      /* FIXME: Currently any arch supported for unwinding supports
-	 unaligned access.  */
       if (bytes == 8)
-	*result = *(const uint64_t *) data->d_buf;
+	*result = read_8ubyte_unaligned_noncvt (data->d_buf);
       else
-	*result = *(const uint32_t *) data->d_buf;
+	*result = read_4ubyte_unaligned_noncvt (data->d_buf);
       return true;
     }
   __libdwfl_seterrno (DWFL_E_ADDR_OUTOFRANGE);
@@ -179,7 +179,7 @@ core_next_thread (Dwfl *dwfl __attribute
 	  break;
       if (item == items + nitems)
 	continue;
-      uint32_t val32 = *(const uint32_t *) (desc + item->offset);
+      uint32_t val32 = read_4ubyte_unaligned_noncvt (desc + item->offset);
       val32 = (elf_getident (core, NULL)[EI_DATA] == ELFDATA2MSB
 		? be32toh (val32) : le32toh (val32));
       pid_t tid = (int32_t) val32;
@@ -230,7 +230,7 @@ core_set_initial_registers (Dwfl_Thread
   assert (item < items + nitems);
   pid_t tid;
   {
-    uint32_t val32 = *(const uint32_t *) (desc + item->offset);
+    uint32_t val32 = read_4ubyte_unaligned_noncvt (desc + item->offset);
     val32 = (elf_getident (core, NULL)[EI_DATA] == ELFDATA2MSB
 	     ? be32toh (val32) : le32toh (val32));
     tid = (int32_t) val32;
@@ -247,14 +247,14 @@ core_set_initial_registers (Dwfl_Thread
       switch (gelf_getclass (core) == ELFCLASS32 ? 32 : 64)
       {
 	case 32:;
-	  uint32_t val32 = *(const uint32_t *) (desc + item->offset);
+	  uint32_t val32 = read_4ubyte_unaligned_noncvt (desc + item->offset);
 	  val32 = (elf_getident (core, NULL)[EI_DATA] == ELFDATA2MSB
 		   ? be32toh (val32) : le32toh (val32));
 	  /* Do a host width conversion.  */
 	  pc = val32;
 	  break;
 	case 64:;
-	  uint64_t val64 = *(const uint64_t *) (desc + item->offset);
+	  uint64_t val64 = read_8ubyte_unaligned_noncvt (desc + item->offset);
 	  val64 = (elf_getident (core, NULL)[EI_DATA] == ELFDATA2MSB
 		   ? be64toh (val64) : le64toh (val64));
 	  pc = val64;
@@ -288,7 +288,7 @@ core_set_initial_registers (Dwfl_Thread
 	  switch (regloc->bits)
 	  {
 	    case 32:;
-	      uint32_t val32 = *(const uint32_t *) reg_desc;
+	      uint32_t val32 = read_4ubyte_unaligned_noncvt (reg_desc);
 	      reg_desc += sizeof val32;
 	      val32 = (elf_getident (core, NULL)[EI_DATA] == ELFDATA2MSB
 		       ? be32toh (val32) : le32toh (val32));
@@ -296,7 +296,7 @@ core_set_initial_registers (Dwfl_Thread
 	      val = val32;
 	      break;
 	    case 64:;
-	      uint64_t val64 = *(const uint64_t *) reg_desc;
+	      uint64_t val64 = read_8ubyte_unaligned_noncvt (reg_desc);
 	      reg_desc += sizeof val64;
 	      val64 = (elf_getident (core, NULL)[EI_DATA] == ELFDATA2MSB
 		       ? be64toh (val64) : le64toh (val64));
@@ -413,7 +413,7 @@ dwfl_core_file_attach (Dwfl *dwfl, Elf *
 	  break;
       if (item == items + nitems)
 	continue;
-      uint32_t val32 = *(const uint32_t *) (desc + item->offset);
+      uint32_t val32 = read_4ubyte_unaligned_noncvt (desc + item->offset);
       val32 = (elf_getident (core, NULL)[EI_DATA] == ELFDATA2MSB
 		? be32toh (val32) : le32toh (val32));
       pid = (int32_t) val32;
